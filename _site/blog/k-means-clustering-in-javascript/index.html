<!DOCTYPE html>
<html lang="en-US" manifest="http://cache.miguelmota.com/cache.appcache">
<head>
  <meta charset="UTF-8">
  <!--
                                        ___                           __
             __                        /\_ \                         /\ \__
    ___ ___ /\_\     __   __  __     __\//\ \         ___ ___     ___\ \ ,_\    __
  /' __` __`\/\ \  /'_ `\/\ \/\ \  /'__`\\ \ \      /' __` __`\  / __`\ \ \/  /'__`\
  /\ \/\ \/\ \ \ \/\ \L\ \ \ \_\ \/\  __/ \_\ \_    /\ \/\ \/\ \/\ \L\ \ \ \_/\ \L\.\_
  \ \_\ \_\ \_\ \_\ \____ \ \____/\ \____\/\____\   \ \_\ \_\ \_\ \____/\ \__\ \__/.\_\
   \/_/\/_/\/_/\/_/\/___L\ \/___/  \/____/\/____/    \/_/\/_/\/_/\/___/  \/__/\/__/\/_/
                     /\____/
                     \_/__/
  -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="description" content="An example of the k-means algorithm in JavaScript.">
  <meta name="keywords" content="miguel mota,web developer,html5 css3 javascript">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Moogs">
  <title>K-Means Clustering in JavaScript » Miguel Mota | Web Developer</title>
  <link rel="canonical" href="http://www.miguelmota.com/blog/k-means-clustering-in-javascript/">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://feeds.feedburner.com/miguelmota">
  <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/assets/images/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/images/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/images/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/images/apple-touch-icon-144x144.png">
  <link rel="apple-touch-startup-image" media="(device-width: 320px)" href="/assets/images/apple-touch-startup-image-320x460.png">
  <link rel="apple-touch-startup-image" media="(device-width: 320px) and (-webkit-device-pixel-ratio: 2)" href="/assets/images/apple-touch-startup-image-640x920.png">
  <link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" href="/assets/images/apple-touch-startup-image-640x1096.png">
  <link rel="apple-touch-startup-image" media="(device-width: 768px) and (orientation: portrait)" href="/assets/images/apple-touch-startup-image-768x1004.png">
  <link rel="apple-touch-startup-image" media="(device-width: 768px) and (orientation: landscape)" href="/assets/images/apple-touch-startup-image-748x1024.png">
  <link rel="apple-touch-startup-image" media="(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)" href="/assets/images/apple-touch-startup-image-1536x2008.png">
  <link rel="apple-touch-startup-image" media="(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)" href="/assets/images/apple-touch-startup-image-2048x1496.png">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="//use.typekit.net/wkl5rpy.js"></script>
  <script>try{Typekit.load();}catch(e){}</script>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  <script src="/assets/scripts/build/site.js"></script>
  <script>
      var _gaq = _gaq || [];
       _gaq.push(['_setAccount', 'UA-12642068-1']);
       _gaq.push(['_setDomainName', '.miguelmota.com']);
      _gaq.push(['_trackPageview']);
       (function() {
           var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
           ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
           var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();
       $(document).on('click', '[data-ga-label]', function() {
         _gaq.push(['_trackEvent', 'Call To Action', 'Click', $(this).attr('data-ga-label')]);
       });
  </script>
</head>
<body id="blog">
    <canvas id="bg-canvas"></canvas>
    <div class="bg-upper"></div>
    <div class="bg-lower"></div>
    <div id="top"></div>
    <img class="hidden" src="/assets/images/miguel-mota-m-logo-500x500.png" alt="">

    <header id="header" class="contain-to-grid fixed">
      <nav class="top-bar">
        <ul class="title-area">
          <li class="name"><a href="/" data-ga-label="Navigation - Logo">Miguel Mota</a></li>
          <li class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></li>
        </ul>
        <section class="top-bar-section">
            <ul id="main-nav" class="right">
              <li class="divider"></li>
              <li ><a href="/" data-ga-label="Navigation - Home"><i class="fa fa-home"></i></a></li>
              <li class="divider"></li>
              <li ><a href="/about" data-ga-label="Navigation - About"><i class="fa fa-bookmark-o"></i> About</a></li>
              <li class="divider"></li>
              <li class="active"><a href="/blog" data-ga-label="Navigation - Blog"><i class="fa fa-lightbulb-o"></i> Thoughts</a></li>
              <li class="divider"></li>
              <li ><a href="/work" data-ga-label="Navigation - Work"><i class="fa fa-laptop"></i> Work</a></li>
              <li class="divider"></li>
              <li ><a href="/contact" data-ga-label="Navigation - Contact"><i class="fa fa-envelope-o"></i> Contact</a></li>
              <li class="divider"></li>
            </ul>
        </section>
      </nav>
    </header>

    <main id="main" role="main">
      <header id="content-header">
    
    <div class="row">
        <div class="large-12 column">
          
            <datetime>25 Feb 2015 <small><i class="fa fa-comment-o"></i> <a href="/blog/k-means-clustering-in-javascript/#disqus_thread" data-disqus-identifier="/blog/k-means-clustering-in-javascript/"></a></small> <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://www.miguelmota.com/blog/k-means-clustering-in-javascript/" data-text="K-Means Clustering in JavaScript" data-size="large" data-related="_moogs" data-ga-label="Blog post - Tweet">Tweet</a></datetime>
<h1 data-text="K-Means Clustering in JavaScript">K-Means Clustering in JavaScript</h1>

          
        </div>
    </div>
    <div id="content-header-bottom">
        <div class="triangle"></div>
    </div>
</header>


<section id="post">
  <div class="row">
    <div class="large-12 column">

      <p>Clustering is grouping of data or dividing a large data set into smaller data sets of some similarity. A well known clustering algorithm in unsupervised machine learning is <a href="http://en.wikipedia.org/wiki/K-means_clustering">K-Means clustering</a>. The K-Means algorithm takes in <code>n</code> observations (data points), and groups them into <code>k</code> clusters, where each observation belongs to a cluster based on the nearest mean (cluster centroid). The distance between a data point and cluster centroid is calculated using the <a href="http://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a>.</p>

<p><a href="http://en.wikipedia.org/wiki/Euclidean_distance"><img src="/blog/k-means-clustering-in-javascript//euclidean-distance-model.png" alt=""></a></p>

<h1 id="procedure">Procedure</h1>

<p>How the K-Means algorithm works is relatively straight forward. We just follow these steps:</p>

<ul>
<li>Step 1. Plot data points.</li>
<li>Step 2. Initialize <code>k</code> additional points which are the seeds (cluster centroids) by plotting them randomly on the graph within the boundaries of the <code>n</code> observation&#39;s dimenion ranges.</li>
<li>Step 3. Assign each <code>n</code> data point to it&#39;s closest cluster centroid (mean).</li>
<li>Step 4. Move the cluster centroid to the average position of all the data points that belong to that mean.</li>
<li>Step 5: Repeat steps 3 and 4 until there is no change in each cluster centroid movement. If means remain the same (nothing moved) then we know the algorithm has finished.</li>
</ul>

<p><code>K</code> is usually found by another algorithm to achieve the best k value, for example, by using the <a href="http://en.wikipedia.org/wiki/Bayesian_information_criterion">Bayesian information criterion</a>, <a href="http://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set#The_Elbow_Method">The Elbow Method</a>, or the <a href="http://en.wikipedia.org/wiki/Rule_of_thumb">Rule of thumb</a>, which is simply <code>k= √(n/2)</code>.</p>

<h1 id="algorithm">Algorithm</h1>

<p><a href="http://en.wikipedia.org/wiki/K-means_clustering"><img src="/blog/k-means-clustering-in-javascript//k-means-clustering-model.png" alt=""></a></p>

<blockquote>
<p>Given a set of observations <code>(x1, x2, …, xn)</code>, where each observation is a d-dimensional real vector, k-means clustering aims to partition the n observations into <code>k (≤ n)</code> sets <code>S = {S1, S2, …, Sk}</code> so as to minimize the within-cluster sum of squares (WCSS) where <code>μi</code> is the mean of points in <code>Si</code>. (<a href="http://en.wikipedia.org/wiki/K-means_clustering">wikipedia</a>)</p>
</blockquote>

<h3 id="credit">Credit</h3>

<p>Most of my understanding and knowledge of the K-Means algorithm and implementation came from <a href="http://burakkanber.com/blog/machine-learning-k-means-clustering-in-javascript-part-1/">this article</a> by <a href="https://twitter.com/bkanber">Burak Kanber</a>.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/**</span>
<span class="cm">* KMeans</span>
<span class="cm">* @constructor</span>
<span class="cm">* @desc KMeans constructor</span>
<span class="cm">* @param {object} options - options object</span>
<span class="cm">* @param {HTMLElement} options.canvas - canvas element</span>
<span class="cm">* @param {data} options.data - data array with points</span>
<span class="cm">* @param {number} options.k - number of cluster centroids</span>
<span class="cm">* @return array with arrays of points</span>
<span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">KMeans</span><span class="p">(</span><span class="nx">opts</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Create new instance if `new` keyword was not used.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">KMeans</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">KMeans</span><span class="p">(</span><span class="nx">opts</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">opts</span> <span class="o">=</span> <span class="nx">opts</span> <span class="o">||</span> <span class="p">{};</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">canvas</span> <span class="o">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">canvas</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s1">&#39;2d&#39;</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>

  <span class="c1">// Number of cluster centroids.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">k</span> <span class="o">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">k</span><span class="p">;</span>

  <span class="c1">// Points to cluster.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>

  <span class="c1">// Keeps track of which cluster centroid index each data point belongs to.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">assignments</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// Get the extents (min,max) for the dimensions.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">extents</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">dataDimensionExtents</span><span class="p">();</span>

  <span class="c1">// Get the range of the dimentions.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">ranges</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">dataExtentRanges</span><span class="p">();</span>

  <span class="c1">// Generate random cluster centroid points.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">means</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">seeds</span><span class="p">();</span>

  <span class="c1">// Generate cluster colors.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">clusterColors</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">clusterColors</span><span class="p">();</span>

  <span class="c1">// Keep track of number of times centroids move.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Clear the canvas.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="s1">&#39;rgb(255,255,255)&#39;</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

  <span class="c1">// Draw the points onto canvas.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">draw</span><span class="p">();</span>

  <span class="c1">// Delay for each draw iteration.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">drawDelay</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

  <span class="c1">// Perform work.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">run</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">* dataDimensionExtents</span>
<span class="cm">* @desc Returns the the minimum and maximum values for each dimention in the data array.</span>
<span class="cm">* @param {array} data - data containing points</span>
<span class="cm">* @return {array} extents - extents for each dimenion</span>
<span class="cm">* @example</span>
<span class="cm">* kmeans.data = [</span>
<span class="cm">*   [2,5],</span>
<span class="cm">*   [4,7],</span>
<span class="cm">*   [3,1]</span>
<span class="cm">* ];</span>
<span class="cm">* var extents = kmeans.dataDimensionExtents();</span>
<span class="cm">* console.log(extents); // [{min: 2, max: 4}, {min: 1, max: 7}]</span>
<span class="cm">*/</span>
<span class="nx">KMeans</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">dataDimensionExtents</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">extents</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">point</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">extents</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">extents</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nx">min</span><span class="o">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="nx">max</span><span class="o">:</span> <span class="mi">0</span><span class="p">};</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">extents</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">min</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">extents</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">min</span> <span class="o">=</span> <span class="nx">point</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">extents</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">extents</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">max</span> <span class="o">=</span> <span class="nx">point</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">extents</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm">* dataExtentRanges</span>
<span class="cm">* @desc Returns the range for each extent</span>
<span class="cm">* @return {array} ranges</span>
<span class="cm">* kmeans.extents = [{min: 2, max: 4}, {min: 1, max: 7}]</span>
<span class="cm">* var ranges = kmeans.dataExtentRanges(extents);</span>
<span class="cm">* console.log(ranges); // [2,6]</span>
<span class="cm">*/</span>
<span class="nx">KMeans</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">dataExtentRanges</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">ranges</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ranges</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">max</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">min</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">ranges</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm">* seeds</span>
<span class="cm">* @desc Returns an array of randomly generated cluster centroid points bounds based on the data dimension ranges.</span>
<span class="cm">* @return {array} cluster centroid points</span>
<span class="cm">* @example</span>
<span class="cm">* var means = kmeans.seeds();</span>
<span class="cm">* console.log(means); // [[2,3],[4,5],[5,2]]</span>
<span class="cm">*/</span>
<span class="nx">KMeans</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">seeds</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">means</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">k</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">mean</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">mean</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">min</span> <span class="o">+</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">ranges</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="nx">means</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">mean</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">means</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm">* assignClusterToDataPoints</span>
<span class="cm">* @desc Calculate Euclidean distance between each point and the cluster center.</span>
<span class="cm">* Assigns each point to closest mean point.</span>
<span class="cm">*</span>
<span class="cm">* The distance between two points is the length of the path connecting them.</span>
<span class="cm">* The distance between points P(p1,p2) and Q(q1,q2) is given by the Pythagorean theorem.</span>
<span class="cm">*</span>
<span class="cm">* distance = square root of ((p1 - q1)^2 + (p2 - q2)^2)</span>
<span class="cm">*</span>
<span class="cm">* For n dimensions, ie P(p1,p2,pn) and Q(q1,q2,qn).</span>
<span class="cm">* d(p,q) = square root of ((p1 - q1)^2 + (p2 - q2)^2 + ... + (pn - qn)^2)</span>
<span class="cm">*</span>
<span class="cm">* http://en.wikipedia.org/wiki/Euclidean_distance</span>
<span class="cm">*/</span>
<span class="nx">KMeans</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assignClusterToDataPoints</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">assignments</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">distances</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">mean</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/* We calculate the Euclidean distance.</span>
<span class="cm">       * √((pi-qi)^2+...+(pn-qn)^2)</span>
<span class="cm">       */</span>

      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">dim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dim</span> <span class="o">&lt;</span> <span class="nx">point</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">dim</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// dif = (pn - qn)</span>
        <span class="kd">var</span> <span class="nx">difference</span> <span class="o">=</span> <span class="nx">point</span><span class="p">[</span><span class="nx">dim</span><span class="p">]</span> <span class="o">-</span> <span class="nx">mean</span><span class="p">[</span><span class="nx">dim</span><span class="p">];</span>

        <span class="c1">// dif = (dif)^2</span>
        <span class="nx">difference</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="nx">difference</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

        <span class="c1">// sum = (difi) + ... + (difn)</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">difference</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// √sum</span>
      <span class="nx">distances</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// After calculating all the distances from the data point to each cluster centroid,</span>
    <span class="c1">// we pick the closest (smallest) distances.</span>
    <span class="nx">assignments</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">distances</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">distances</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">assignments</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * moveMeans</span>
<span class="cm"> * @desc Update the positions of the the cluster centroids (means) to the average positions</span>
<span class="cm"> * of all data points that belong to that mean.</span>
<span class="cm"> */</span>
<span class="nx">KMeans</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">moveMeans</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">sums</span> <span class="o">=</span> <span class="nx">fillArray</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">counts</span> <span class="o">=</span> <span class="nx">fillArray</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">moved</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">meanIndex</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dim</span><span class="p">;</span>

  <span class="c1">// Clear location sums for each dimension.</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fillArray</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// For each cluster, get sum of point coordinates in every dimension.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">pointIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">pointIndex</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">assignments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">pointIndex</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">meanIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">assignments</span><span class="p">[</span><span class="nx">pointIndex</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">pointIndex</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">mean</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">];</span>

    <span class="nx">counts</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="nx">dim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dim</span> <span class="o">&lt;</span> <span class="nx">mean</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">dim</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">sums</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">point</span><span class="p">[</span><span class="nx">dim</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/* If cluster centroid (mean) is not longer assigned to any points,</span>
<span class="cm">   * move it somewhere else randomly within range of points.</span>
<span class="cm">   */</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">meanIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">meanIndex</span> <span class="o">&lt;</span> <span class="nx">sums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">meanIndex</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">===</span> <span class="nx">counts</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">sums</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">];</span>

      <span class="k">for</span> <span class="p">(</span><span class="nx">dim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dim</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">dim</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sums</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="nx">dim</span><span class="p">].</span><span class="nx">min</span> <span class="o">+</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">ranges</span><span class="p">[</span><span class="nx">dim</span><span class="p">]);</span>
      <span class="p">}</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="nx">dim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dim</span> <span class="o">&lt;</span> <span class="nx">sums</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span> <span class="nx">dim</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">sums</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">]</span> <span class="o">/=</span> <span class="nx">counts</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">];</span>
      <span class="nx">sums</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="nx">sums</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">])</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/* If current means does not equal to new means, then</span>
<span class="cm">   * move cluster centroid closer to average point.</span>
<span class="cm">   */</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="o">!==</span> <span class="nx">sums</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">diff</span><span class="p">;</span>
    <span class="nx">moved</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

    <span class="c1">// Nudge means 1/nth of the way toward average point.</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">meanIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">meanIndex</span> <span class="o">&lt;</span> <span class="nx">sums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">meanIndex</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="nx">dim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dim</span> <span class="o">&lt;</span> <span class="nx">sums</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span> <span class="nx">dim</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">diff</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sums</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">stepsPerIteration</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">diff</span> <span class="o">/</span> <span class="nx">stepsPerIteration</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">])</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sums</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">][</span><span class="nx">dim</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">moved</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * run</span>
<span class="cm"> * @desc Reassigns nearest cluster centroids (means) to data points,</span>
<span class="cm"> * and checks if cluster centroids (means) have moved, otherwise</span>
<span class="cm"> * end program.</span>
<span class="cm"> */</span>
<span class="nx">KMeans</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">run</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="nx">iterations</span><span class="p">;</span>

  <span class="c1">// Reassign points to nearest cluster centroids.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">assignments</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">assignClusterToDataPoints</span><span class="p">();</span>

  <span class="c1">// Returns true if the cluster centroids have moved location since the last iteration.</span>
  <span class="kd">var</span> <span class="nx">meansMoved</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">moveMeans</span><span class="p">();</span>

  <span class="cm">/* If cluster centroids moved then</span>
<span class="cm">   *rerun to reassign points to new cluster centroid (means) positions.</span>
<span class="cm">   */</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">meansMoved</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">draw</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">run</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">drawDelay</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Otherwise task has completed.</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Iteration took for completion: &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">iterations</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">KMeans</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">draw</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Slightly clear the canvas to make new draws visible.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="s1">&#39;rgba(255,255,255, 0.2)&#39;</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">point</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>

  <span class="cm">/* Iterate though points draw line from their origin to their cluster centroid.</span>
<span class="cm">  * `assignments` contains cluster centroid index for each point.</span>
<span class="cm">  */</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">assignments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">meanIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">assignments</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nx">point</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">mean</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">meanIndex</span><span class="p">];</span>

    <span class="c1">// Make lines that will get drawn alpha transparent.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">globalAlpha</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>

    <span class="c1">// Push current state onto the stack.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">();</span>

    <span class="c1">// Begin path from current point origin.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span>
      <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)),</span>
      <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">);</span>

    <span class="c1">// Draw path from the point (moveTo) to the cluster centroid.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">lineTo</span><span class="p">(</span>
      <span class="p">(</span><span class="nx">mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)),</span>
      <span class="p">(</span><span class="nx">mean</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">);</span>

    <span class="c1">// Draw a stroke on the path to make it visible.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">strokeStyle</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">stroke</span><span class="p">();</span>
    <span class="c1">//this.context.closePath();</span>

    <span class="c1">// Restore saved state.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">restore</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Plot every point onto canvas.</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>

    <span class="nx">point</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>

    <span class="c1">// Make style fully opaque.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">globalAlpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// Move canvas origin on the grid to current point position.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span>
      <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)),</span>
      <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">);</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">();</span>

    <span class="c1">// Draw point circle.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">arc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

    <span class="c1">// Set the color for current point based on which cluster it belongs to.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">strokeStyle</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">clusterColor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">assignments</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>

    <span class="c1">// Draw a stroke to make circle visible.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">stroke</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">closePath</span><span class="p">();</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">restore</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Draw cluster centroids (means).</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>

    <span class="nx">point</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">means</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">globalAlpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">clusterColor</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span>
      <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)),</span>
      <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">extents</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">arc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">fill</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">closePath</span><span class="p">();</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">restore</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm">* clusterColors</span>
<span class="cm">* @desc Generate a random colors for clusters.</span>
<span class="cm">* @return random colors</span>
<span class="cm">*/</span>
<span class="nx">KMeans</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clusterColors</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">colors</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// Generate point color for each cluster.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">colors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="o">+</span><span class="p">((</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">))</span><span class="o">|</span><span class="mi">0</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">colors</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm">* clusterColor</span>
<span class="cm">* @desc Get color for cluster.</span>
<span class="cm">* @param {number} index - cluster (mean) index</span>
<span class="cm">* @return color for cluster</span>
<span class="cm">*/</span>
<span class="nx">KMeans</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clusterColor</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">clusterColors</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm">* fillArray</span>
<span class="cm">* @desc Returns a prefilled array.</span>
<span class="cm">* @param {number} length - length of array</span>
<span class="cm">* @param {*} value - value to prefill with.</span>
<span class="cm">* @return array with prefilled values.</span>
<span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">fillArray</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">length</span><span class="p">)).</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">val</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<h1 id="usage">Usage</h1>

<p>Let&#39;s see it in action.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">var data = [
  [6,5],
  [9,10],
  [10,1],
  [5,5],
  [7,7],
  [4,1],
  [10,7],
  [6,8],
  [10,2],
  [9,4],
  [2,5],
  [9,1],
  [10,9],
  [2,8],
  [1,1],
  [6,10],
  [3,8],
  [2,3],
  [7,9],
  [7,7],
  [3,6],
  [5,8],
  [7,5],
  [10,9],
  [10,9]
];

var kmeans = new KMeans({
  canvas: document.getElementById(&#39;canvas&#39;),
  data: data,
  k: 3
});
</code></pre></div>
<p><a href="/blog/k-means-clustering-in-javascript//demo"><img src="/blog/k-means-clustering-in-javascript//k-means-clustering-screenshot.png" alt=""></a></p>

<p><a href="/blog/k-means-clustering-in-javascript//demo">View the demo »</a></p>

<h1 id="conclusion">Conclusion</h1>

<p>As you can see in the demo, K-Means does a fairly good job in clustering data. If you run the algorithm thousands of times you can determine the best solution based on which solutions got returned the most often. Sometimes your dataset contains <a href="http://en.wikipedia.org/wiki/Outlier">outliers</a> and the <em>mean</em> may not be the best measure for clustering because the clusters may be heavily skewed, so in this scenario the <em><a href="http://en.wikipedia.org/wiki/K-medians_clustering">K-Medians</a></em> algorithm is your best bet.</p>


      <div class="tags">
  
    <a href="/tag/k-means">#k-means</a>
  
    <a href="/tag/machine learning">#machine learning</a>
  
    <a href="/tag/data mining">#data mining</a>
  
    <a href="/tag/algorithm">#algorithm</a>
  
    <a href="/tag/JavaScript">#JavaScript</a>
  
    <a href="/tag/demo">#demo</a>
  
</div>


    </div>
  </div>

  
    <div id="related-posts" class="row">
      <div class="large-6 column">
        
    

    <h3>Previous post</h3>

      <dl class="posts-list">
        <dt><datetime>16 Feb 2015</datetime></dt>
        <dd><h2><a href="/blog/naive-bayes-classifier-in-javascript/">Naive Bayes Classifier in JavaScript</a> <small><i class="icon-comment-alt"></i> <a href="/blog/naive-bayes-classifier-in-javascript/#disqus_thread" data-disqus-identifier="/blog/naive-bayes-classifier-in-javascript/"></a></small></h2></dd>
      </dl>

    



      </div>
      <div class="large-6 column">

        <h3>See also...</h3>

        <dl class="posts-list">
          
            <dt><datetime>16 Feb 2015</datetime></dt>
<dd><h2><a href="/blog/naive-bayes-classifier-in-javascript/">Naive Bayes Classifier in JavaScript</a> <small><i class="icon-comment-alt"></i> <a href="/blog/naive-bayes-classifier-in-javascript/#disqus_thread" data-disqus-identifier="/blog/naive-bayes-classifier-in-javascript/"></a></small></h2>
</dd>
          
            <dt><datetime>01 Feb 2015</datetime></dt>
<dd><h2><a href="/blog/pixelate-images-with-canvas/">Pixelate images with Canvas</a> <small><i class="icon-comment-alt"></i> <a href="/blog/pixelate-images-with-canvas/#disqus_thread" data-disqus-identifier="/blog/pixelate-images-with-canvas/"></a></small></h2>
</dd>
          
            <dt><datetime>19 Jul 2014</datetime></dt>
<dd><h2><a href="/blog/bitwise-operators-in-javascript/">Bitwise operators in JavaScript</a> <small><i class="icon-comment-alt"></i> <a href="/blog/bitwise-operators-in-javascript/#disqus_thread" data-disqus-identifier="/blog/bitwise-operators-in-javascript/"></a></small></h2>
</dd>
          
            <dt><datetime>20 Jun 2014</datetime></dt>
<dd><h2><a href="/blog/es6-examples/">ES6 Examples</a> <small><i class="icon-comment-alt"></i> <a href="/blog/es6-examples/#disqus_thread" data-disqus-identifier="/blog/es6-examples/"></a></small></h2>
</dd>
          
            <dt><datetime>14 Mar 2014</datetime></dt>
<dd><h2><a href="/blog/deployment-with-git/">Deployment with Git</a> <small><i class="icon-comment-alt"></i> <a href="/blog/deployment-with-git/#disqus_thread" data-disqus-identifier="/blog/deployment-with-git/"></a></small></h2>
</dd>
          
        </dl>

      </div>
    </div>
  

  <div id="comments" class="row">
    <div class="large-12 column">
      <div id="disqus_thread"></div>
    </div>
  </div>

</section>

<script>
    var disqus_shortname = 'miguelmota';
    var disqus_identifier = '/blog/k-means-clustering-in-javascript/';
    var disqus_url = 'http://www.miguelmota.com/blog/k-means-clustering-in-javascript/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>

    </main>

    <footer id="footer">
      <div class="row">
        <div class="large-12 column">
          <p>
            <span class="break"><span>© 2015 Moogs™.</span> <span>Made with <i class="fa fa-heart"></i></span></span> <a class="hidden" href="https://plus.google.com/102174577273194387652" rel="author">Google+</a>

            <a href="https://twitter.com/_moogs" class="twitter-follow-button" data-show-count="true" data-size="large" data-ga-label="Footer - Follow Twitter">Follow @_moogs</a>

          </p>
        </div>
      </div>
    </footer>

    <a id="forkme" href="https://github.com/miguelmota/miguelmota.github.com" target="_blank" data-ga-label="Fork me on Github"><img src="/assets/images/forkme_right_darkblue_121621.png" alt=""></a>

    <script src="//maps.google.com/maps/api/js?sensor=false"></script>
    <script src="//google-maps-utility-library-v3.googlecode.com/svn/trunk/infobox/src/infobox.js"></script>
  </body>
</html>
