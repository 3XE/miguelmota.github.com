function HiddenMarkovModel() {
  if (!(this instanceof HiddenMarkovModel)) {
    return new HiddenMarkovModel();
  }

  this.initialStateVector = [];
  this.currentStateVector = [];
  this.transitionStateMatrix = [];
  this.emissionStateMatrix = [];
  this.iterationsCount = 0;
}

HiddenMarkovModel.prototype.setInitialStateVector = function(vector) {
  this.initialStateVector = vector;
  this.currentStateVector = vector;
};

HiddenMarkovModel.prototype.getInitialStateVector = function() {
  return this.initialStateVector;
};

HiddenMarkovModel.prototype.setTransitionMatrix = function(matrix) {
  this.transitionStateMatrix = matrix;
};

HiddenMarkovModel.prototype.getTransitionMatrix = function() {
  return this.transitionStateMatrix;
};

HiddenMarkovModel.prototype.setEmissionMatrix = function(matrix) {
  this.emissionStateMatrix = matrix;
};

HiddenMarkovModel.prototype.getEmissionMatrix = function() {
  return this.emissionStateMatrix;
};

HiddenMarkovModel.prototype.getIterationsCount = function() {
  return this.iterationsCount;
};

HiddenMarkovModel.prototype.getCurrentStateVector = function() {
  return this.currentStateVector;
};

HiddenMarkovModel.prototype.nextStateProbability = function() {
  var CS = this.currentStateVector;
  var TM = this.transitionStateMatrix;
  var vector = [];

  for (var i = 0; i < CS.length; i++) {
    var value = 0;
    for (var j = 0; j < TM.length; j++) {
      value += (CS[j]*TM[j][i]);
    }
    vector = vector.concat(value);
  }

  this.currentStateVector = vector;
  this.iterationsCount += 1;

  return vector;
};

HiddenMarkovModel.prototype.forward = function(emissionsSequence) {
  var PI = this.initialStateVector;
  var A = this.transitionStateMatrix;
  var B = this.emissionStateMatrix;
  var O = emissionsSequence;
  var T = O.length;
  var N = A.length;
  var alpha = [];
  var probability = 0;

  /*
   * Example
   * Hidden = Healthy, Fever
   * Emission = Normal, Cold, Dizzy
   *
   * PI = [H, F]
   * O = [N, C, D]
   *
   * H : N C D
   * F : N C D
   */

  // Initialization
  for (var i = 0; i < N; i++) {
    alpha[i] = [];
    /*
     * P_t1(N) = Pinit(H) * P(N|H)
     * P_t1(N) = Pinit(F) * P(N|F)
     */
     alpha[0][i] = PI[i] * B[i][O[0]];
  }

  // Recursion
  for (var i = 1; i < T; i++) {
    alpha[i] = [];
    for (var j = 0; j < N; j++) {
      /*
       * P_t2(C) = (P_t1(H) * P(H|H) * P(C|H)) + (P_t1(F) + P(H|F) * P(C|H)) + ...
       * P_t2(C) = (P_t1(H) * P(F|H) * P(C|F)) + (P_t1(F) + P(F|F) * P(C|F)) + ...
       */
      var result = 0;
      for (var l = 0; l < N; l++) {
        result += alpha[i-1][l] * A[l][j] * B[j][O[i]];
      }
      alpha[i][j] = result;
    }
  }

  // Termination
  for (var i = 0; i < N; i++) {
    probability += alpha[T-1][i];
  }

  return probability;
};


var HMM = HiddenMarkovModel();

// U U`
//HMM.setInitialStateVector([0.5, 0.5]);
// H F
HMM.setInitialStateVector([0.6, 0.4]);

 // underlying markov chain
HMM.setTransitionMatrix([
    // SUNN    CLOUD    FOG
    //[0.8, 0.05, 0.15],
    //[0.2, 0.6, 0.2],
    //[0.2, 0.3, 0.5]

    [0.7, 0.3],
    [0.4, 0.6]
]);

// what's observable, "the paramters of HMM"
HMM.setEmissionMatrix([
    // N C D
    [0.5, 0.4, 0.1], //U: {'sunny': 0.5, 'rainy': 0.4, 'foggy': 0.1},
    [0.1, 0.3, 0.6]  //No U: {sunn': 0.1, 'rainy': 0.3, 'fog': 0.6}
]);

 // patient says she feels, norm on day1, cold on day2, diz on day3
//Get the most possible hidden sequence of the given observation:
//The doctor has a question: what is the most likely sequence
//ofhealth condition of the patient would explain these observations? This is answered by the Viterbi algorithm
//var result = hmm.viterbi(model, [0, 1, 2]);
//console.log(result); // H H FEV

// This reveals that the observations ['normal', 'cold', 'dizzy'] were most likely generated by states ['Healthy', 'Healthy',
//'Fever']. In other words, given the observed activities, the patient was most likely to have been healthy both on the first
//day when she felt normal as well as on the second day when she felt
//cold, and then she contracted a fever the third day


// observation distribution aka emission distribution, initial state distribution

// N C D
// What is the probability that the given model is able generate such sequence above?
result = HMM.forward([0, 1, 2]);
console.log(result);

    //console.log('goal1', '0.3 0.7 0.4 + 0.04000000000000001 0.4 0.4');
    //console.log('goal2', '0.3 0.3 0.3 + 0.04000000000000001 0.6 0.3');
